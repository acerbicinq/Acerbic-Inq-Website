---
import BaseLayout from "../../layouts/BaseLayout.astro";
import { client, urlFor } from "../../lib/sanity";

export async function getStaticPaths() {
  const episodes = await client.fetch(`
    *[_type == "podcastEpisode"] {
      slug,
      title
    }
  `);
  
  return episodes.map((episode) => ({
    params: { slug: episode.slug.current },
  }));
}

const { slug } = Astro.params;

const episode = await client.fetch(`
  *[_type == "podcastEpisode" && slug.current == $slug][0] {
    _id,
    title,
    slug,
    episodeNumber,
    publishedAt,
    description,
    coverArt,
    audioFile{
      asset->{
        _id,
        url
      }
    },
    videoFile{
      asset->{
        _id,
        url
      }
    },
    duration,
    guest,
    chapters[]{ 
      ...,
      interludeTracks[]{
        ...,
        fallbackAudio{
          asset->{
            _id,
            url
          }
        }
      }
    },
    transcriptFile{
      asset->{
        _id,
        url
      }
    },
    transcriptText,
    transcript,
    tags,
    showNotes,
    radioSettings
  }
`, { slug });

if (!episode) {
  return Astro.redirect("/404");
}

const pageTitle = `Episode ${episode.episodeNumber}: ${episode.title}`;
---

<BaseLayout pageTitle={pageTitle}>
  <div class="episode-container">
    <header class="episode-header">
      <div class="episode-cover-section">
        {episode.coverArt && (
          <img 
            src={urlFor(episode.coverArt).width(400).height(400).url()} 
            alt={`Cover art for ${episode.title}`}
            class="episode-cover-large"
          />
        )}
      </div>
      
      <div class="episode-info">
        <span class="episode-number">Episode {episode.episodeNumber}</span>
        <h1>{episode.title}</h1>
        {episode.description && <p class="episode-description">{episode.description}</p>}
        
        <div class="episode-meta">
          {episode.duration && <span class="duration">‚è±Ô∏è {episode.duration}</span>}
          {episode.guest?.name && <span class="guest">üé§ with {episode.guest.name}</span>}
          <time datetime={episode.publishedAt}>
            {new Date(episode.publishedAt).toLocaleDateString()}
          </time>
        </div>
        
        {episode.tags && episode.tags.length > 0 && (
          <div class="episode-tags">
            {episode.tags.map((tag) => (
              <span class="tag">{tag}</span>
            ))}
          </div>
        )}
      </div>
    </header>

    <!-- Media Player Controls -->
    <div class="player-controls">
      <div class="media-selector">
        <button class="media-btn active" data-type="audio">üéß Audio</button>
        {episode.videoFile && (
          <button class="media-btn" data-type="video">üìπ Video</button>
        )}
      </div>
      
      <div class="control-group">
        <label class="control-label">
          <input type="checkbox" id="showTranscript" />
          <span class="checkbox-custom"></span>
          Show Transcript
        </label>
      </div>
    </div>

    <!-- Media Player -->
    <div class="media-player">
      {episode.audioFile && (
        <div class="audio-player-container active" data-media="audio">
          <audio id="mainAudio" controls preload="metadata">
            <source src={episode.audioFile?.asset?.url} type="audio/mpeg" />
            Your browser does not support the audio element.
          </audio>
        </div>
      )}
      
      {episode.videoFile && (
        <div class="video-player-container" data-media="video">
          <video id="mainVideo" controls preload="metadata">
            <source src={episode.videoFile?.asset?.url} type="video/mp4" />
            Your browser does not support the video element.
          </video>
        </div>
      )}
    </div>

    <!-- Chapters -->
    {episode.chapters && episode.chapters.length > 0 && (
      <div class="chapters-section">
        <h2>Chapters</h2>
        <div class="chapters-list">
          {episode.chapters.map((chapter, index) => (
            <div class="chapter-item" data-chapter={index}>
              <div class="chapter-status">
                <span class="chapter-number">{index + 1}</span>
                <div class="chapter-progress">
                  <div class="progress-bar">
                    <div class="progress-fill" data-chapter-index={index}></div>
                  </div>
                </div>
              </div>
              
              <div class="chapter-info">
                <h3 class="chapter-title">{chapter.title}</h3>
                <div class="chapter-time">
                  <span class="time-range">{chapter.startTime} - {chapter.endTime}</span>
                  <span class="chapter-status-text" data-chapter-index={index}>Not Started</span>
                </div>
                {chapter.description && (
                  <p class="chapter-description">{chapter.description}</p>
                )}
                
                {/* Interlude Tracks */}
                {chapter.interludeTracks && chapter.interludeTracks.length > 0 && (
                  <div class="interlude-section">
                    <h4 class="interlude-title">üéµ Interlude Music</h4>
                    <div class="interlude-tracks" id={`interlude-tracks-${index}`}>
                      {chapter.interludeTracks.map((track, trackIndex) => (
                        <div class="interlude-track" data-track-index={trackIndex}>
                          <div class="track-info">
                            <strong>{track.songTitle}</strong> by {track.artist}
                            {track.album && <span class="album-info"> ‚Ä¢ {track.album}</span>}
                            {track.duration && <span class="duration-info"> ({track.duration})</span>}
                          </div>
                          
                          <div class="streaming-options">
                            {track.streamingLinks?.filter(link => link.platform !== 'spotify').map((link, linkIndex) => (
                              <div class="streaming-option" data-platform={link.platform}>
                                {link.platform === 'youtube-music' && (link.url || link.embedCode) && (
                                  <div class="youtube-embed-container" 
                                       data-youtube-url={link.url || (link.embedCode ? link.embedCode.match(/src="([^"]*)"/) ? link.embedCode.match(/src="([^"]*)"/)[1] : '' : '')} 
                                       data-track-title={track.title || track.songTitle} 
                                       data-track-artist={track.artist}>
                                    {/* Show placeholder in audio mode, YouTube player will replace this in video mode during interludes */}
                                    <div class="youtube-placeholder">
                                      <div class="youtube-placeholder-content">
                                        <span class="youtube-icon">‚ñ∂</span>
                                        <p>YouTube video will play here during interludes in video mode</p>
                                        <small>Track: {track.title || track.songTitle} by {track.artist}</small>
                                      </div>
                                    </div>
                                  </div>
                                )}
                                
                                <a 
                                  href={link.url} 
                                  target="_blank" 
                                  rel="noopener noreferrer"
                                  class="external-link"
                                >
                                  Open in {link.platform === 'youtube-music' ? 'YouTube Music' : 
                                           link.platform === 'apple-music' ? 'Apple Music' :
                                           link.platform.charAt(0).toUpperCase() + link.platform.slice(1)}
                                </a>
                              </div>
                            ))}
                          </div>
                          
                          {/* Fallback Audio Player */}
                          {track.fallbackAudio && (
                            <div class="fallback-audio-section">
                              <h5>üéß Fallback Player:</h5>
                              <audio controls preload="metadata" crossorigin="anonymous">
                                <source src={track.fallbackAudio.asset?.url} type="audio/mpeg" />
                                Your browser does not support the audio element.
                              </audio>
                            </div>
                          )}
                        </div>
                      ))}
                    </div>
                  </div>
                )}
              </div>
              
              <button class="jump-to-chapter" data-start-time={chapter.startTime}>
                ‚ñ∂ Jump to Chapter
              </button>
            </div>
          ))}
        </div>
      </div>
    )}


    <!-- Guest Info -->
    {episode.guest && (
      <div class="guest-section">
        <h2>Guest: {episode.guest.name}</h2>
        {episode.guest.bio && <p>{episode.guest.bio}</p>}
        
        <div class="guest-links">
          {episode.guest.website && (
            <a href={episode.guest.website} target="_blank" rel="noopener noreferrer">
              Website
            </a>
          )}
          {episode.guest.social?.map((social) => (
            <a href={social.url} target="_blank" rel="noopener noreferrer">
              {social.platform.charAt(0).toUpperCase() + social.platform.slice(1)}
            </a>
          ))}
        </div>
      </div>
    )}

    <!-- Show Notes -->
    {episode.showNotes && (
      <div class="show-notes-section">
        <h2>Show Notes</h2>
        <div class="show-notes-content">
          <!-- Rich text content would need a component to render properly -->
          <div class="rich-text-placeholder">
            [Show notes content would be rendered here]
          </div>
        </div>
      </div>
    )}

    <!-- Transcript Section -->
    {episode.transcript && (episode.transcript.transcriptData || episode.transcript.transcriptFile) && (
      <div class="transcript-section">
        <h2>üìú Episode Transcript</h2>
        <div class="transcript-controls">
          <button id="transcript-toggle" class="transcript-toggle-btn">
            <span class="toggle-text">Show Transcript</span>
          </button>
          <div class="transcript-info">
            <span class="transcript-status">Ready for sync</span>
            <span class="format-detected" id="format-detected">Detecting format...</span>
          </div>
        </div>
        
        <!-- Raw transcript data for parsing -->
        <script type="application/json" id="transcript-raw-data" set:html={JSON.stringify({
          transcriptData: (episode.transcript?.transcriptData && typeof episode.transcript.transcriptData === 'string') ? episode.transcript.transcriptData : '',
          transcriptFile: episode.transcript?.transcriptFile || null,
          defaultSpeaker: (episode.transcript?.defaultSpeaker && typeof episode.transcript.defaultSpeaker === 'string') ? episode.transcript.defaultSpeaker : 'Host',
          enableSync: episode.transcript?.enableSync === true || (episode.transcript?.transcriptData && episode.transcript.transcriptData.trim().length > 0),
          formatHint: (episode.transcript?.formatHint && typeof episode.transcript.formatHint === 'string') ? episode.transcript.formatHint : 'auto'
        })}></script>
        
        <!-- Scrolling Transcript Container (Audio Mode) -->
        <div id="transcript-container" class="transcript-container" style="display: none;">
          <div class="transcript-content" id="transcript-content">
            <!-- Transcript segments will be dynamically populated by JavaScript -->
            <div class="transcript-loading">
              <p>Loading transcript...</p>
            </div>
          </div>
        </div>
      </div>
    )}

    <!-- Video Subtitle Overlay (Video Mode) -->
    <div id="subtitle-overlay" class="subtitle-overlay">
      <div class="subtitle-text"></div>
    </div>

    <!-- Navigation -->
    <nav class="episode-navigation">
      <a href="/podcast" class="back-link">‚Üê Back to Podcast</a>
    </nav>

  </div>
</BaseLayout>

<style>
  .episode-container {
    max-width: 1000px;
    margin: 0 auto;
    padding: 2rem;
  }
  
  .episode-header {
    display: grid;
    grid-template-columns: 300px 1fr;
    gap: 2rem;
    margin-bottom: 2rem;
  }
  
  .episode-cover-large {
    width: 100%;
    border-radius: 12px;
  }
  
  .episode-number {
    background: #007acc;
    color: white;
    padding: 0.25rem 0.5rem;
    border-radius: 4px;
    font-size: 0.9rem;
    font-weight: bold;
  }
  
  .episode-info h1 {
    margin: 0.5rem 0 1rem 0;
    font-size: 2rem;
    line-height: 1.2;
  }
  
  .episode-description {
    color: #666;
    line-height: 1.5;
    margin-bottom: 1rem;
  }
  
  .episode-meta {
    display: flex;
    flex-wrap: wrap;
    gap: 1rem;
    margin-bottom: 1rem;
    color: #666;
  }
  
  .episode-tags {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
  }
  
  .tag {
    background: #f0f0f0;
    padding: 0.25rem 0.5rem;
    border-radius: 12px;
    font-size: 0.8rem;
    color: #666;
  }
  
  .player-controls {
    background: #f8f9fa;
    padding: 1.5rem;
    border-radius: 12px;
    margin-bottom: 2rem;
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-wrap: wrap;
    gap: 1rem;
  }
  
  .media-selector {
    display: flex;
    gap: 1rem;
  }
  
  .media-btn {
    background: #e9ecef;
    border: none;
    padding: 0.5rem 1rem;
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.3s ease;
  }
  
  .media-btn.active {
    background: #007acc;
    color: white;
  }
  
  .control-group {
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }
  
  .control-label {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    cursor: pointer;
  }
  
  .checkbox-custom {
    width: 20px;
    height: 20px;
    background: white;
    border: 2px solid #ddd;
    border-radius: 4px;
    display: inline-block;
    position: relative;
  }
  
  input[type="checkbox"] {
    display: none;
  }
  
  input[type="checkbox"]:checked + .checkbox-custom {
    background: #007acc;
    border-color: #007acc;
  }
  
  input[type="checkbox"]:checked + .checkbox-custom::after {
    content: '‚úì';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: white;
    font-weight: bold;
  }
  
  .media-player {
    margin-bottom: 2rem;
  }
  
  .audio-player-container,
  .video-player-container {
    display: none;
  }
  
  .audio-player-container.active,
  .video-player-container.active {
    display: block;
  }
  
  #mainAudio,
  #mainVideo {
    width: 100%;
    border-radius: 8px;
  }
  
  .chapters-section {
    margin-bottom: 2rem;
  }
  
  .chapters-list {
    display: flex;
    flex-direction: column;
    gap: 1rem;
  }
  
  .chapter-item {
    background: white;
    border: 1px solid #e1e1e1;
    border-radius: 8px;
    padding: 1.5rem;
    cursor: pointer;
    transition: all 0.3s ease;
  }
  
  .chapter-item:hover {
    border-color: #007acc;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  }
  
  .chapter-title {
    margin: 0 0 0.5rem 0;
    color: #007acc;
  }
  
  .chapter-time {
    font-size: 0.9rem;
    color: #666;
    margin-bottom: 0.5rem;
  }
  
  .chapter-description {
    color: #666;
    line-height: 1.5;
    margin-bottom: 1rem;
  }
  
  .jump-to-chapter {
    background: #007acc;
    color: white;
    border: none;
    padding: 0.5rem 1rem;
    border-radius: 6px;
    cursor: pointer;
    font-size: 0.9rem;
    margin-top: 1rem;
    transition: background 0.3s ease;
  }
  
  .jump-to-chapter:hover {
    background: #005a9e;
  }
  
  .chapter-item.active {
    border-color: #007acc;
    background-color: #f0f8ff;
  }
  
  .transcript-section {
    background: #f8f9fa;
    padding: 1.5rem;
    border-radius: 12px;
    margin-bottom: 2rem;
  }
  
  .transcript-content {
    height: 400px;
    overflow-y: auto;
    padding: 1rem;
    background: white;
    border-radius: 8px;
    scroll-behavior: smooth;
  }
  
  .transcript-entry {
    display: flex;
    gap: 1rem;
    padding: 0.5rem 0;
    border-bottom: 1px solid #f0f0f0;
    transition: background-color 0.3s ease;
  }
  
  .transcript-entry.current {
    background-color: #e6f3ff;
    border-left: 4px solid #007acc;
    padding-left: 1rem;
    margin-left: -1rem;
    box-shadow: 0 2px 4px rgba(0, 122, 204, 0.2);
    transform: translateX(2px);
  }
  
  .transcript-entry.current .timestamp {
    background-color: #007acc;
    color: white;
    padding: 0.2rem 0.4rem;
    border-radius: 4px;
  }
  
  .timestamp {
    color: #007acc;
    font-weight: bold;
    min-width: 80px;
    cursor: pointer;
  }
  
  .speaker {
    font-weight: bold;
    min-width: 100px;
  }
  
  .text {
    flex: 1;
    line-height: 1.5;
  }
  
  .guest-section,
  .show-notes-section {
    background: #f8f9fa;
    padding: 1.5rem;
    border-radius: 12px;
    margin-bottom: 2rem;
  }
  
  .guest-links {
    display: flex;
    gap: 1rem;
    margin-top: 1rem;
  }
  
  .guest-links a {
    background: #007acc;
    color: white;
    padding: 0.5rem 1rem;
    border-radius: 6px;
    text-decoration: none;
  }
  
  .back-link {
    display: inline-block;
    background: #f0f0f0;
    padding: 0.5rem 1rem;
    border-radius: 6px;
    text-decoration: none;
    color: #333;
  }

  /* Interlude Styles */
  .interlude-section {
    margin-top: 1rem;
    padding: 1rem;
    background: rgba(0, 122, 204, 0.05);
    border-radius: 8px;
    border-left: 4px solid #007acc;
  }

  .interlude-title {
    margin: 0 0 0.75rem 0;
    font-size: 1rem;
    color: #007acc;
    font-weight: 600;
  }

  .interlude-tracks {
    display: flex;
    flex-direction: column;
    gap: 1rem;
  }

  .interlude-track {
    background: white;
    border-radius: 8px;
    padding: 1rem;
    border: 1px solid rgba(0, 122, 204, 0.2);
  }

  .track-info {
    margin-bottom: 0.75rem;
    line-height: 1.4;
  }

  .album-info, .duration-info {
    color: #666;
    font-weight: normal;
  }

  .streaming-options {
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
  }

  .streaming-option {
    position: relative;
  }

  .youtube-embed-container {
    position: relative;
    padding-bottom: 56.25%; /* 16:9 aspect ratio */
    height: 0;
    overflow: hidden;
    border-radius: 8px;
    background: #f0f0f0;
  }

  .youtube-embed-container iframe {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border-radius: 8px;
  }

  .youtube-placeholder {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    background: linear-gradient(135deg, #f0f0f0 0%, #e0e0e0 100%);
    border-radius: 8px;
  }

  .youtube-placeholder-content {
    text-align: center;
    color: #666;
  }

  .youtube-icon {
    font-size: 2rem;
    color: #ff0000;
    display: block;
    margin-bottom: 0.5rem;
  }

  .youtube-placeholder p {
    margin: 0;
    font-size: 0.9rem;
    max-width: 200px;
    line-height: 1.4;
  }

  .external-link {
    display: inline-block;
    margin-top: 0.5rem;
    padding: 0.5rem 1rem;
    background: #007acc;
    color: white;
    text-decoration: none;
    border-radius: 6px;
    font-size: 0.9rem;
    font-weight: 500;
    transition: background 0.2s ease;
  }

  .external-link:hover {
    background: #005a9e;
  }


  .fallback-audio-section {
    margin-top: 1rem;
    padding: 0.75rem;
    background: rgba(0, 122, 204, 0.1);
    border-radius: 6px;
    border: 1px dashed #007acc;
  }

  .fallback-audio-section h5 {
    margin: 0 0 0.5rem 0;
    font-size: 0.9rem;
    color: #007acc;
    font-weight: 600;
  }

  .fallback-audio-section audio {
    width: 100%;
    height: 40px;
  }

  /* Audio-only view styles - hide visual streaming elements but keep functionality */
  .audio-only-view .youtube-embed-container {
    display: none !important;
  }
  
  .audio-only-view .streaming-option {
    display: none !important;
  }
  
  .audio-only-view .external-link {
    display: none !important;
  }
  
  .audio-only-view .fallback-audio-section {
    display: none !important;
  }
  
  .audio-only-view .streaming-options {
    display: none !important;
  }


  /* Transcript Section Styles */
  .transcript-section {
    background: #f9f9f9;
    border-radius: 12px;
    padding: 1.5rem;
    margin: 2rem 0;
    border: 1px solid #e1e1e1;
  }

  .transcript-section h2 {
    margin: 0 0 1rem 0;
    color: #333;
    font-size: 1.4rem;
  }

  .transcript-controls {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1rem;
    padding-bottom: 0.5rem;
    border-bottom: 1px solid #e1e1e1;
  }

  .transcript-toggle-btn {
    background: #007acc;
    color: white;
    border: none;
    border-radius: 6px;
    padding: 0.5rem 1rem;
    cursor: pointer;
    font-size: 0.9rem;
    transition: background 0.2s ease;
  }

  .transcript-toggle-btn:hover {
    background: #005a99;
  }

  .transcript-info {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    flex-wrap: wrap;
  }

  .transcript-status {
    font-size: 0.85rem;
    color: #666;
    padding: 0.25rem 0.5rem;
    background: #e8f4f8;
    border-radius: 4px;
  }

  .format-detected {
    font-size: 0.8rem;
    color: #888;
    padding: 0.2rem 0.4rem;
    background: #f8f8f8;
    border-radius: 3px;
    border: 1px solid #ddd;
  }

  .format-detected.detected {
    background: #d4edda;
    color: #155724;
    border-color: #c3e6cb;
  }

  .transcript-loading {
    text-align: center;
    padding: 2rem;
    color: #666;
    font-style: italic;
  }

  .transcript-status.syncing {
    background: #fff3cd;
    color: #856404;
  }

  .transcript-status.active {
    background: #d4edda;
    color: #155724;
  }

  /* Transcript Container - Scrolling view for audio mode */
  .transcript-container {
    max-height: 400px;
    overflow-y: auto;
    border: 1px solid #ddd;
    border-radius: 8px;
    background: white;
    padding: 1rem;
  }

  .transcript-content {
    line-height: 1.6;
  }

  .transcript-segment {
    display: flex;
    align-items: flex-start;
    gap: 0.75rem;
    padding: 0.5rem 0;
    border-bottom: 1px solid #f0f0f0;
    transition: all 0.3s ease;
    scroll-margin-top: 1rem;
  }

  .transcript-segment:last-child {
    border-bottom: none;
  }

  .transcript-segment.active {
    background: #e8f4f8;
    border-radius: 6px;
    padding: 0.75rem;
    margin: 0.25rem 0;
    border-bottom: 1px solid #007acc;
    box-shadow: 0 2px 4px rgba(0, 122, 204, 0.1);
  }

  .transcript-segment .timestamp {
    font-family: 'Courier New', monospace;
    font-size: 0.8rem;
    color: #007acc;
    font-weight: bold;
    min-width: 60px;
    flex-shrink: 0;
  }

  .transcript-segment .speaker {
    font-weight: bold;
    color: #333;
    min-width: 80px;
    flex-shrink: 0;
  }

  .transcript-segment .text {
    flex: 1;
    color: #444;
  }

  .transcript-segment[data-type="music"] {
    font-style: italic;
    opacity: 0.7;
  }

  .transcript-segment[data-type="music"] .text {
    color: #666;
  }

  /* Subtitle Overlay - For video mode */
  .subtitle-overlay {
    position: absolute;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 9999 !important;
    pointer-events: none;
    display: none;
    width: 100%;
  }

  .subtitle-text {
    background: rgba(0, 0, 0, 0.95) !important;
    color: #ffffff !important;
    padding: 1rem 2rem;
    border-radius: 8px;
    font-size: 1.3rem !important;
    font-weight: 700;
    line-height: 1.4;
    text-align: center;
    max-width: 90%;
    margin: 0 auto;
    word-wrap: break-word;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
    border: 2px solid rgba(255, 255, 255, 0.2);
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
  }

  /* Video container positioning for subtitles */
  .media-container {
    position: relative;
  }

  .media-container .subtitle-overlay {
    position: absolute;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
  }

  /* Hide transcript container in audio-only mode, show subtitles in video mode */
  .audio-only-view .subtitle-overlay {
    display: none !important;
  }

  .audio-only-view .transcript-container {
    display: block !important;
  }

  /* Animation for pulsing status indicators */
  @keyframes pulse {
    0% { opacity: 1; }
    50% { opacity: 0.6; }
    100% { opacity: 1; }
  }
  
  @media (max-width: 768px) {
    .episode-header {
      grid-template-columns: 1fr;
      text-align: center;
    }
    
    .episode-cover-large {
      max-width: 300px;
      margin: 0 auto;
    }
    
    .player-controls {
      flex-direction: column;
      align-items: center;
      gap: 1rem;
    }
    
    .media-selector {
      justify-content: center;
    }

    .interlude-section {
      margin-top: 0.75rem;
      padding: 0.75rem;
    }

    .interlude-track {
      padding: 0.75rem;
    }
  }
</style>

<!-- Episode data for JavaScript -->
<script type="application/json" id="episode-data" set:html={JSON.stringify({
  chapters: episode.chapters || [],
  transcript: episode.transcript || {},
  transcriptText: episode.transcript?.transcriptData || ""
})}></script>

<script type="module">
  document.addEventListener('DOMContentLoaded', function() {
    console.log('Phase 1 Podcast player initializing...');
    
    // Focus on YouTube interlude system - Spotify removed for now
    
    // Get episode data
    const episodeDataScript = document.getElementById('episode-data');
    const episodeData = episodeDataScript ? JSON.parse(episodeDataScript.textContent) : { chapters: [] };
    
    console.log('Episode data loaded:', episodeData);
    
    // Transcript parsing function
    function parseTranscriptText() {
      const transcriptText = episodeData.transcriptText;
      if (!transcriptText) return [];
      
      const entries = [];
      const lines = transcriptText.split('\n');
      
      for (const line of lines) {
        if (line.trim() === '') continue;
        
        // Support multiple formats:
        // [MM:SS] Speaker: Text
        // [MM:SS] Text (no speaker)
        // MM:SS - Speaker: Text  
        // MM:SS - Text (no speaker)
        // MM:SS Speaker: Text
        // MM:SS Text (no speaker)
        
        const patterns = [
          /^\[(\d{1,2}:\d{2}(?::\d{2})?)\]\s*([^:]+):\s*(.+)$/,     // [MM:SS] Speaker: Text
          /^\[(\d{1,2}:\d{2}(?::\d{2})?)\]\s*(.+)$/,               // [MM:SS] Text (no speaker)
          /^(\d{1,2}:\d{2}(?::\d{2})?)\s*-\s*([^:]+):\s*(.+)$/,    // MM:SS - Speaker: Text
          /^(\d{1,2}:\d{2}(?::\d{2})?)\s*-\s*(.+)$/,               // MM:SS - Text (no speaker)
          /^(\d{1,2}:\d{2}(?::\d{2})?)\s+([^:]+):\s*(.+)$/,        // MM:SS Speaker: Text
          /^(\d{1,2}:\d{2}(?::\d{2})?)\s+(.+)$/,                   // MM:SS Text (no speaker)
        ];
        
        let match = null;
        let patternIndex = -1;
        for (let i = 0; i < patterns.length; i++) {
          match = line.match(patterns[i]);
          if (match) {
            patternIndex = i;
            break;
          }
        }
        
        if (match) {
          let timestamp, speaker, text;
          
          // Handle different pattern matches based on capture groups
          if (patternIndex === 1 || patternIndex === 3 || patternIndex === 5) {
            // No speaker patterns: timestamp, text
            [, timestamp, text] = match;
            speaker = '';
          } else {
            // Speaker patterns: timestamp, speaker, text
            [, timestamp, speaker, text] = match;
          }
          
          entries.push({
            timestamp: timestamp.trim(),
            speaker: speaker ? speaker.trim() : '',
            text: text.trim()
          });
          
          console.log(`Parsed: ${timestamp.trim()} | "${speaker ? speaker.trim() : 'No speaker'}" | ${text.trim().substring(0, 50)}...`);
        } else {
          // If no timestamp pattern, treat as continuation of previous entry
          if (entries.length > 0) {
            entries[entries.length - 1].text += ' ' + line.trim();
          }
        }
      }
      
      console.log('Parsed transcript entries:', entries.length);
      return entries;
    }
    
    // Parse transcript from text if needed
    if (!episodeData.transcript || episodeData.transcript.length === 0) {
      episodeData.transcript = parseTranscriptText();
    }
    
    // Basic Player Controller
    let currentMediaPlayer = null;
    // Make media player globally accessible for transcript sync
    window.currentMediaPlayer = null;
    let currentChapterIndex = 0;
    let lastSyncTime = 0;
    
    // Get media elements
    const mediaBtns = document.querySelectorAll('.media-btn');
    const audioContainer = document.querySelector('.audio-player-container');
    const videoContainer = document.querySelector('.video-player-container');
    const audio = document.getElementById('mainAudio');
    const video = document.getElementById('mainVideo');
    
    console.log('Media elements found:', {
      audio: !!audio,
      video: !!video,
      audioContainer: !!audioContainer,
      videoContainer: !!videoContainer,
      mediaBtns: mediaBtns.length
    });
    
    // Set initial media player (prefer audio if available)
    if (audio) {
      currentMediaPlayer = audio;
      window.currentMediaPlayer = audio;
      console.log('Set audio as initial player');
      
      // Set initial audio-only view since audio is default
      const episodeContainer = document.querySelector('.episode-container');
      if (episodeContainer) {
        episodeContainer.classList.add('audio-only-view');
        console.log('Initial audio-only view enabled - YouTube iframes hidden');
        console.log('Initial episode container classes:', episodeContainer.className);
        console.log('Initial YouTube containers found:', document.querySelectorAll('.youtube-embed-container').length);
      }
    } else if (video) {
      currentMediaPlayer = video;
      window.currentMediaPlayer = video;
      console.log('Set video as initial player');
    }
    
    // Media type switching with time sync
    mediaBtns.forEach(btn => {
      btn.addEventListener('click', function() {
        const type = this.dataset.type;
        console.log('Switching to media type:', type);
        
        // Store current time and playback state
        let wasPlaying = false;
        let currentTime = 0;
        
        if (currentMediaPlayer) {
          wasPlaying = !currentMediaPlayer.paused;
          currentTime = currentMediaPlayer.currentTime;
          if (wasPlaying) {
            currentMediaPlayer.pause();
          }
        }
        
        // Update button states
        mediaBtns.forEach(b => b.classList.remove('active'));
        this.classList.add('active');
        
        // Toggle audio-only view class on episode container
        const episodeContainer = document.querySelector('.episode-container');
        if (type === 'audio') {
          episodeContainer.classList.add('audio-only-view');
          console.log('Enabled audio-only view - hiding YouTube iframes');
          console.log('Episode container classes:', episodeContainer.className);
          console.log('YouTube containers found:', document.querySelectorAll('.youtube-embed-container').length);
        } else {
          episodeContainer.classList.remove('audio-only-view');
          console.log('Disabled audio-only view - showing YouTube iframes');
          console.log('Episode container classes:', episodeContainer.className);
        }
        
        // Notify transcript system of mode change
        if (window.transcriptSync) {
          console.log('Notifying transcript system of mode change to:', type);
          window.transcriptSync.checkDisplayMode();
          // Reconnect to the new media player after a short delay to ensure media switch is complete
          setTimeout(() => {
            window.transcriptSync.reconnectMediaPlayer();
          }, 100);
        }
        
        
        // Switch media containers and players
        if (type === 'audio' && audio && audioContainer) {
          audioContainer.classList.add('active');
          if (videoContainer) videoContainer.classList.remove('active');
          currentMediaPlayer = audio;
      window.currentMediaPlayer = audio;
          
          // Sync time and resume playback if needed
          audio.currentTime = currentTime;
          if (wasPlaying) {
            audio.play().catch(e => console.log('Audio play failed:', e));
          }
          console.log('Switched to audio player at time:', currentTime);
          
        } else if (type === 'video' && video && videoContainer) {
          if (audioContainer) audioContainer.classList.remove('active');
          videoContainer.classList.add('active');
          currentMediaPlayer = video;
      window.currentMediaPlayer = video;
          
          // Sync time and resume playback if needed
          video.currentTime = currentTime;
          if (wasPlaying) {
            video.play().catch(e => console.log('Video play failed:', e));
          }
          console.log('Switched to video player at time:', currentTime);
        }
      });
    });
    
    // Chapter Management
    function parseTimeToSeconds(timeString) {
      if (!timeString) return 0;
      const parts = timeString.split(':').map(Number);
      if (parts.length === 2) {
        return parts[0] * 60 + parts[1]; // MM:SS
      } else if (parts.length === 3) {
        return parts[0] * 3600 + parts[1] * 60 + parts[2]; // HH:MM:SS
      }
      return 0;
    }
    
    // Seamless Audio Playback System
    const ENABLE_SEAMLESS_INTERLUDES = true; // Set to true to enable seamless interludes
    let isPlayingInterlude = false;
    let interludeQueue = [];
    let currentInterludeIndex = 0;
    let pendingChapterStart = null;
    let userPaused = false;
    
    let lastTriggeredChapter = -1; // Prevent multiple triggers
    
    function checkForChapterEnd() {
      if (!ENABLE_SEAMLESS_INTERLUDES || !currentMediaPlayer || episodeData.chapters.length === 0 || isPlayingInterlude || userPaused) {
        return;
      }
      
      const currentTime = currentMediaPlayer.currentTime;
      
      // Find which chapter we're currently in
      let currentChapterData = null;
      let currentChapterIdx = -1;
      
      for (let i = 0; i < episodeData.chapters.length; i++) {
        const chapter = episodeData.chapters[i];
        const startTime = parseTimeToSeconds(chapter.startTime);
        const endTime = parseTimeToSeconds(chapter.endTime);
        
        if (currentTime >= startTime && currentTime <= endTime) {
          currentChapterData = chapter;
          currentChapterIdx = i;
          break;
        }
      }
      
      // If we're in a chapter that has interludes and we're near the end
      if (currentChapterData && 
          currentChapterData.interludeTracks && 
          currentChapterData.interludeTracks.length > 0 &&
          lastTriggeredChapter !== currentChapterIdx) {
        
        const startTime = parseTimeToSeconds(currentChapterData.startTime);
        const endTime = parseTimeToSeconds(currentChapterData.endTime);
        const chapterDuration = endTime - startTime;
        const timeIntoChapter = currentTime - startTime;
        
        // Trigger when we're 95% through the chapter or within 0.5 seconds of the end
        if (timeIntoChapter >= (chapterDuration * 0.95) || currentTime >= (endTime - 0.5)) {
          console.log(`üéµ TRIGGER: Chapter ${currentChapterIdx + 1} ending at ${currentTime.toFixed(1)}s (${timeIntoChapter.toFixed(1)}s into chapter)`);
          console.log(`Chapter data:`, currentChapterData);
          console.log(`Has interludeTracks:`, !!(currentChapterData.interludeTracks && currentChapterData.interludeTracks.length));
          if (currentChapterData.interludeTracks) {
            console.log(`Number of interlude tracks:`, currentChapterData.interludeTracks.length);
          }
          lastTriggeredChapter = currentChapterIdx;
          startInterludeSequence(currentChapterIdx);
        }
      }
    }
    
    function startInterludeSequence(chapterIndex) {
      const chapter = episodeData.chapters[chapterIndex];
      if (!chapter.interludeTracks || chapter.interludeTracks.length === 0) {
        console.log('No interludes found for chapter', chapterIndex + 1);
        return;
      }
      
      console.log(`Starting interlude sequence for chapter ${chapterIndex + 1}`);
      
      // Pause the main podcast
      if (currentMediaPlayer && !currentMediaPlayer.paused) {
        currentMediaPlayer.pause();
      }
      
      isPlayingInterlude = true;
      currentInterludeIndex = 0;
      
      // Set up the next chapter start time
      const nextChapter = episodeData.chapters[chapterIndex + 1];
      if (nextChapter) {
        pendingChapterStart = parseTimeToSeconds(nextChapter.startTime);
        console.log(`Will resume podcast at chapter ${chapterIndex + 2}: ${nextChapter.title} (${pendingChapterStart}s)`);
      } else {
        console.log('This is the last chapter, no resume point set');
        pendingChapterStart = null;
      }
      
      // Build interlude queue - prioritize YouTube, fallback to audio
      interludeQueue = [];
      const interludeContainer = document.getElementById(`interlude-tracks-${chapterIndex}`);
      console.log(`Looking for interlude container: interlude-tracks-${chapterIndex}`);
      console.log(`Interlude container found:`, !!interludeContainer);
      
      if (interludeContainer) {
        // Try to build YouTube queue first - simplified check
        if (window.youtubeInterludeSystem) {
          console.log('üì∫ Building YouTube interlude queue');
          
          const youtubeTracks = [];
          
          // Extract YouTube URLs from the chapter's interlude tracks
          chapter.interludeTracks.forEach((track, index) => {
            console.log(`Processing track ${index}:`, track);
            console.log(`Track title: "${track.title}"`);
            console.log(`Track songTitle: "${track.songTitle}"`);
            console.log(`Track artist: "${track.artist}"`);
            console.log(`All track keys:`, Object.keys(track));
            console.log(`Track streamingLinks:`, track.streamingLinks);
            
            const youtubeLink = track.streamingLinks?.find(link => 
              link.platform === 'youtube-music' || link.platform === 'youtube'
            );
            
            console.log(`Found YouTube link:`, youtubeLink);
            
            if (youtubeLink && youtubeLink.url) {
              const trackData = {
                type: 'youtube',
                url: youtubeLink.url,
                title: track.title || track.songTitle, // Use title first, fallback to songTitle
                artist: track.artist,
                streamingLinks: track.streamingLinks
              };
              
              youtubeTracks.push(trackData);
              console.log(`‚úÖ Added YouTube track ${index}:`, trackData);
            } else {
              console.log(`‚ùå No valid YouTube link for track ${index}`);
            }
          });
          
          if (youtubeTracks.length > 0) {
            interludeQueue = youtubeTracks;
            console.log(`‚úÖ Using ${interludeQueue.length} YouTube tracks for interludes`);
          }
        }
        
        // Fallback to audio elements if no YouTube tracks
        if (interludeQueue.length === 0) {
          console.log('üéß Building fallback audio queue');
          const fallbackAudios = interludeContainer.querySelectorAll('.fallback-audio-section audio');
          interludeQueue = Array.from(fallbackAudios).map(audio => ({
            type: 'audio',
            element: audio,
            title: 'Fallback Audio'
          }));
          console.log(`Found ${interludeQueue.length} fallback audio tracks`);
        }
      } else {
        console.log(`‚ùå Could not find interlude container with ID: interlude-tracks-${chapterIndex}`);
      }
      
      if (interludeQueue.length === 0) {
        console.log('‚ùå No interlude tracks found, ending interlude sequence immediately');
        endInterludeSequence();
        return;
      }
      
      // Visual feedback
      showInterludeStatus(`üéµ Playing interlude music (Track 1 of ${interludeQueue.length})`);
      
      // Start first interlude track
      playNextInterlude();
    }
    
    function playNextInterlude() {
      if (userPaused) {
        console.log('User paused, stopping interlude sequence');
        return;
      }
      
      if (currentInterludeIndex >= interludeQueue.length) {
        // All interludes finished, resume podcast
        endInterludeSequence();
        return;
      }
      
      const track = interludeQueue[currentInterludeIndex];
      if (!track) {
        currentInterludeIndex++;
        playNextInterlude();
        return;
      }
      
      console.log(`Playing interlude ${currentInterludeIndex + 1} of ${interludeQueue.length} (${track.type}): ${track.title || 'Unknown'}`);
      
      // Update status
      const statusMessage = track.type === 'youtube' 
        ? `üì∫ Playing from YouTube (Track ${currentInterludeIndex + 1} of ${interludeQueue.length}): ${track.title} by ${track.artist}`
        : `üéß Playing fallback audio (Track ${currentInterludeIndex + 1} of ${interludeQueue.length})`;
      showInterludeStatus(statusMessage);
      
      if (track.type === 'youtube') {
        // Play YouTube track with detailed logging
        console.log('About to play YouTube track:', {
          title: track.title,
          artist: track.artist,
          url: track.url,
          streamingLinks: track.streamingLinks
        });
        
        window.playYouTubeInterlude(track).then(() => {
          console.log('YouTube track ended successfully, moving to next interlude');
          currentInterludeIndex++;
          setTimeout(() => {
            playNextInterlude();
          }, 500);
        }).catch((error) => {
          console.error(`Failed to play YouTube track: ${track.title || 'Unknown'}`, error);
          console.error('Track data:', track);
          // Fall back to next track
          currentInterludeIndex++;
          setTimeout(() => playNextInterlude(), 500);
        });
      } else {
        // Play fallback audio
        playFallbackInterlude(track);
      }
    }
    
    // YouTube interlude function is now handled in the YouTube script section
    
    function playFallbackInterlude(track) {
      const audio = track.element;
      
      // Set up event listener for when this track ends
      const handleEnded = () => {
        audio.removeEventListener('ended', handleEnded);
        currentInterludeIndex++;
        
        // Small delay before next track
        setTimeout(() => {
          playNextInterlude();
        }, 500);
      };
      
      audio.addEventListener('ended', handleEnded);
      audio.volume = 0.4; // Set reasonable volume
      
      // Play the interlude
      audio.play().catch((error) => {
        console.log(`Could not play fallback interlude ${currentInterludeIndex + 1}:`, error.message);
        // Skip to next track if this one fails
        currentInterludeIndex++;
        setTimeout(() => playNextInterlude(), 500);
      });
    }
    
    function endInterludeSequence() {
      console.log('Interlude sequence complete, resuming podcast...');
      
      isPlayingInterlude = false;
      interludeQueue = [];
      currentInterludeIndex = 0;
      
      // Resume podcast at next chapter
      if (pendingChapterStart !== null && currentMediaPlayer && !userPaused) {
        currentMediaPlayer.currentTime = pendingChapterStart;
        currentMediaPlayer.play().then(() => {
          console.log(`Resumed podcast at ${pendingChapterStart}s`);
          hideInterludeStatus();
        }).catch((error) => {
          console.log('Could not resume podcast:', error.message);
          hideInterludeStatus();
        });
      } else {
        hideInterludeStatus();
      }
      
      pendingChapterStart = null;
    }
    
    function showInterludeStatus(message) {
      let statusElement = document.getElementById('interlude-status');
      if (!statusElement) {
        statusElement = document.createElement('div');
        statusElement.id = 'interlude-status';
        statusElement.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          background: #007acc;
          color: white;
          padding: 1rem;
          border-radius: 8px;
          box-shadow: 0 4px 12px rgba(0,0,0,0.3);
          z-index: 1000;
          font-weight: 500;
          max-width: 300px;
        `;
        document.body.appendChild(statusElement);
      }
      statusElement.textContent = message;
      statusElement.style.display = 'block';
    }
    
    function hideInterludeStatus() {
      const statusElement = document.getElementById('interlude-status');
      if (statusElement) {
        statusElement.style.display = 'none';
      }
    }
    
    function stopAllPlayback() {
      console.log('stopAllPlayback called');
      userPaused = true;
      
      // Stop any playing interlude first
      if (isPlayingInterlude && interludeQueue[currentInterludeIndex]) {
        const currentTrack = interludeQueue[currentInterludeIndex];
        
        if (currentTrack.type === 'youtube') {
          // Stop YouTube playback
          window.stopYouTubeInterlude();
        } else if (currentTrack.element && !currentTrack.element.paused) {
          // Stop fallback audio
          currentTrack.element.pause();
        }
      }
      
      hideInterludeStatus();
      console.log('All playback stopped by user');
    }
    
    function resumePlayback() {
      console.log('resumePlayback called, isPlayingInterlude:', isPlayingInterlude);
      userPaused = false;
      
      if (isPlayingInterlude) {
        // Resume interlude sequence
        console.log('Resuming interlude playback');
        showInterludeStatus(`üéµ Playing interlude music (Track ${currentInterludeIndex + 1} of ${interludeQueue.length})`);
        playNextInterlude();
      }
      // Don't manually play the main podcast here - let the browser's native controls handle it
    }
    
    function updateCurrentChapter() {
      if (!currentMediaPlayer || episodeData.chapters.length === 0 || isPlayingInterlude) {
        return;
      }
      
      const currentTime = currentMediaPlayer.currentTime;
      
      // Don't update too frequently
      if (Math.abs(currentTime - lastSyncTime) < 0.5) {
        return;
      }
      lastSyncTime = currentTime;
      
      // Find current chapter for highlighting
      let newChapterIndex = -1;
      for (let i = 0; i < episodeData.chapters.length; i++) {
        const chapter = episodeData.chapters[i];
        const startTime = parseTimeToSeconds(chapter.startTime);
        const endTime = parseTimeToSeconds(chapter.endTime);
        
        if (currentTime >= startTime && currentTime <= endTime) {
          newChapterIndex = i;
          break;
        }
      }
      
      // Update chapter highlighting and reset trigger when switching chapters
      if (newChapterIndex !== currentChapterIndex) {
        const chapterItems = document.querySelectorAll('.chapter-item');
        
        // Remove previous highlighting
        chapterItems.forEach(item => item.classList.remove('active'));
        
        // Add new highlighting
        if (newChapterIndex >= 0 && chapterItems[newChapterIndex]) {
          chapterItems[newChapterIndex].classList.add('active');
          console.log('Now in chapter:', episodeData.chapters[newChapterIndex].title);
        }
        
        // Reset trigger when moving to a new chapter
        lastTriggeredChapter = -1;
        currentChapterIndex = newChapterIndex;
      }
      
      // Only check for chapter end after chapter highlighting is updated (if enabled)
      if (ENABLE_SEAMLESS_INTERLUDES) {
        try {
          checkForChapterEnd();
        } catch (error) {
          console.error('Error in checkForChapterEnd:', error);
          // Disable interlude system if there's an error
          isPlayingInterlude = false;
        }
      }
    }
    
    // Chapter navigation buttons
    const jumpButtons = document.querySelectorAll('.jump-to-chapter');
    jumpButtons.forEach((button, index) => {
      button.addEventListener('click', function() {
        const startTime = parseTimeToSeconds(this.dataset.startTime);
        if (currentMediaPlayer) {
          currentMediaPlayer.currentTime = startTime;
          console.log(`Jumped to chapter ${index + 1} at ${startTime}s`);
          
          // Highlight the chapter immediately
          const chapterItems = document.querySelectorAll('.chapter-item');
          chapterItems.forEach(item => item.classList.remove('active'));
          if (chapterItems[index]) {
            chapterItems[index].classList.add('active');
          }
        }
      });
    });
    
    // Chapter item click navigation
    const chapterItems = document.querySelectorAll('.chapter-item');
    chapterItems.forEach((item, index) => {
      item.addEventListener('click', function() {
        const chapter = episodeData.chapters[index];
        if (chapter && currentMediaPlayer) {
          const startTime = parseTimeToSeconds(chapter.startTime);
          currentMediaPlayer.currentTime = startTime;
          console.log(`Clicked to chapter ${index + 1}: ${chapter.title}`);
        }
      });
    });
    
    // Add time update listeners for chapter and transcript tracking
    if (audio) {
      audio.addEventListener('timeupdate', handleTimeUpdate);
      audio.addEventListener('loadedmetadata', () => {
        console.log('Audio loaded, duration:', audio.duration);
      });
      
      // Hook into play/pause for seamless control (only if enabled)
      if (ENABLE_SEAMLESS_INTERLUDES) {
        audio.addEventListener('play', () => {
          console.log('Main audio play triggered');
          if (!isPlayingInterlude) { // Only resume if we're not in the middle of interludes
            resumePlayback();
          }
        });
        
        audio.addEventListener('pause', () => {
          console.log('Main audio pause triggered, isPlayingInterlude:', isPlayingInterlude);
          if (!isPlayingInterlude) { // Only stop if we're not transitioning to interludes
            stopAllPlayback();
          } else {
            console.log('Ignoring pause event - transitioning to interlude playback');
          }
        });
      }
    }
    if (video) {
      video.addEventListener('timeupdate', handleTimeUpdate);
      video.addEventListener('loadedmetadata', () => {
        console.log('Video loaded, duration:', video.duration);
      });
      
      // Hook into play/pause for seamless control (only if enabled)
      if (ENABLE_SEAMLESS_INTERLUDES) {
        video.addEventListener('play', () => {
          console.log('Main video play triggered');
          if (!isPlayingInterlude) { // Only resume if we're not in the middle of interludes
            resumePlayback();
          }
        });
        
        video.addEventListener('pause', () => {
          console.log('Main video pause triggered, isPlayingInterlude:', isPlayingInterlude);
          if (!isPlayingInterlude) { // Only stop if we're not transitioning to interludes
            stopAllPlayback();
          } else {
            console.log('Ignoring pause event - transitioning to interlude playback');
          }
        });
      }
    }
    
    // Transcript toggle
    const transcriptToggle = document.getElementById('showTranscript');
    const transcriptSection = document.querySelector('.transcript-section');
    
    if (transcriptToggle && transcriptSection) {
      transcriptToggle.addEventListener('change', function() {
        if (this.checked) {
          transcriptSection.style.display = 'block';
          console.log('Transcript shown');
        } else {
          transcriptSection.style.display = 'none';
          console.log('Transcript hidden');
        }
      });
    }
    
    // Interactive transcript functionality
    function updateTranscriptSync() {
      if (!currentMediaPlayer) return;
      
      const currentTime = currentMediaPlayer.currentTime;
      const transcriptEntries = document.querySelectorAll('.transcript-entry');
      
      if (transcriptEntries.length === 0) return;
      
      console.log(`Syncing transcript at ${currentTime.toFixed(1)}s`);
      
      // Find the current transcript entry
      let currentEntry = null;
      let bestMatch = null;
      let closestTime = -1;
      
      for (let i = 0; i < transcriptEntries.length; i++) {
        const entry = transcriptEntries[i];
        const timestamp = entry.dataset.timestamp;
        const entryTime = parseTimeToSeconds(timestamp);
        
        console.log(`Entry ${i}: ${timestamp} (${entryTime}s)`);
        
        // Find the entry that starts at or before current time
        if (entryTime <= currentTime) {
          if (entryTime > closestTime) {
            closestTime = entryTime;
            bestMatch = entry;
          }
        }
      }
      
      // If we're at the very beginning (less than first timestamp), show first entry
      if (!bestMatch && currentTime < 5) {
        bestMatch = transcriptEntries[0];
        console.log('Using first entry for beginning of episode');
      }
      
      currentEntry = bestMatch;
      
      // Update highlighting
      transcriptEntries.forEach(entry => entry.classList.remove('current'));
      if (currentEntry) {
        currentEntry.classList.add('current');
        console.log(`Highlighting: ${currentEntry.dataset.timestamp}`);
        
        // Auto-scroll to current entry if transcript is visible
        const transcriptSection = document.querySelector('.transcript-section');
        const transcriptContent = document.querySelector('.transcript-content');
        if (transcriptSection && transcriptSection.style.display !== 'none' && transcriptContent) {
          // Calculate position within the transcript container
          const entryTop = currentEntry.offsetTop;
          const containerHeight = transcriptContent.clientHeight;
          const scrollPosition = entryTop - (containerHeight / 4); // Position entry at top quarter of container
          
          transcriptContent.scrollTo({
            top: Math.max(0, scrollPosition),
            behavior: 'smooth'
          });
        }
      } else {
        console.log('No transcript entry found for current time');
      }
    }
    
    // Transcript timestamp navigation
    const timestampElements = document.querySelectorAll('.timestamp');
    timestampElements.forEach(timestamp => {
      timestamp.addEventListener('click', function() {
        const timeString = this.textContent;
        const seconds = parseTimeToSeconds(timeString);
        if (currentMediaPlayer) {
          currentMediaPlayer.currentTime = seconds;
          console.log(`Jumped to transcript time: ${timeString} (${seconds}s)`);
        }
      });
    });
    
    // Add transcript sync to time update listeners with throttling
    let lastTranscriptUpdate = 0;
    function handleTimeUpdate() {
      updateCurrentChapter();
      
      // Throttle transcript updates to every 0.5 seconds
      const now = Date.now();
      if (now - lastTranscriptUpdate > 500) {
        updateTranscriptSync();
        lastTranscriptUpdate = now;
      }
    }
    
    console.log('Phase 1 podcast player initialized - Basic playback with chapter navigation');
  });
</script>

<!-- YouTube Interlude System -->
<script>
  // YouTube Interlude System - Simple and effective
  let youtubeInterludeSystem = {
    currentYouTubePlayer: null,
    youtubeAPIReady: false,
    interludeQueue: [],
    currentInterludeIndex: 0,
    isPlayingInterlude: false,
    pendingChapterStart: null,
    userPaused: false
  };

  // Load YouTube IFrame API - simple approach
  function loadYouTubeAPI() {
    if (window.YT && window.YT.Player) {
      youtubeInterludeSystem.youtubeAPIReady = true;
      console.log('YouTube API already loaded');
      return;
    }

    window.onYouTubeIframeAPIReady = function() {
      youtubeInterludeSystem.youtubeAPIReady = true;
      console.log('YouTube IFrame API ready');
    };

    const script = document.createElement('script');
    script.src = 'https://www.youtube.com/iframe_api';
    document.head.appendChild(script);
  }

  // Extract YouTube video ID from URL
  function getYouTubeVideoId(url) {
    if (!url) return null;
    const match = url.match(/(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([^&\n?#]+)/);
    return match ? match[1] : null;
  }


  // Check if currently in video mode
  function isCurrentlyVideoMode() {
    const episodeContainer = document.querySelector('.episode-container');
    return episodeContainer && !episodeContainer.classList.contains('audio-only-view');
  }

  // Play YouTube interlude
  async function playYouTubeInterlude(track) {
    return new Promise((resolve, reject) => {
      console.log('=== YouTube Interlude Debug ===');
      console.log('Received track data:', track);
      console.log('Track title:', track.title);
      console.log('Track songTitle:', track.songTitle);
      console.log('Track artist:', track.artist);
      console.log('Track URL:', track.url);
      console.log('Track streamingLinks:', track.streamingLinks);
      
      if (!youtubeInterludeSystem.youtubeAPIReady) {
        console.error('YouTube API not ready');
        reject(new Error('YouTube API not ready'));
        return;
      }

      // Try multiple ways to find the YouTube URL
      let youtubeUrl = null;
      let videoId = null;
      
      // Method 1: Direct URL property
      if (track.url) {
        videoId = getYouTubeVideoId(track.url);
        if (videoId) {
          youtubeUrl = track.url;
          console.log('Found YouTube URL via direct URL property:', youtubeUrl);
        }
      }
      
      // Method 2: Find in streaming links
      if (!youtubeUrl && track.streamingLinks) {
        const youtubeLink = track.streamingLinks.find(link => 
          link.platform === 'youtube-music' || link.platform === 'youtube'
        );
        
        if (youtubeLink) {
          videoId = getYouTubeVideoId(youtubeLink.url);
          if (videoId) {
            youtubeUrl = youtubeLink.url;
            console.log('Found YouTube URL via streaming links:', youtubeUrl);
          }
        }
      }

      if (!youtubeUrl || !videoId) {
        console.error('No valid YouTube URL found for track');
        console.error('Track data:', track);
        reject(new Error('No YouTube link'));
        return;
      }

      const trackTitle = track.title || track.songTitle || 'Unknown Track';
      const trackArtist = track.artist || 'Unknown Artist';
      console.log(`Playing YouTube track: ${trackTitle} by ${trackArtist} (${videoId})`);

      // Determine if we should use visible or hidden player
      const isVideoMode = isCurrentlyVideoMode();
      console.log('Current mode:', isVideoMode ? 'video' : 'audio');

      let playerContainer;
      let playerConfig;

      if (isVideoMode) {
        // Find the corresponding YouTube embed container for this track
        const embedContainers = document.querySelectorAll('.youtube-embed-container');
        let targetContainer = null;
        
        for (const container of embedContainers) {
          const containerUrl = container.dataset.youtubeUrl;
          console.log('Checking container URL:', containerUrl, 'against track URL:', youtubeUrl);
          if (containerUrl && containerUrl === youtubeUrl) {
            targetContainer = container;
            console.log('Found matching container!', targetContainer);
            break;
          }
        }
        
        console.log('Total embed containers found:', embedContainers.length);
        console.log('Target container found:', !!targetContainer);

        if (targetContainer) {
          console.log('Using visible YouTube player in embed container');
          playerContainer = targetContainer;
          
          // Clear placeholder content
          targetContainer.innerHTML = '';
          
          playerConfig = {
            height: '100%',
            width: '100%',
            videoId: videoId,
            playerVars: {
              autoplay: 1,
              controls: 1,
              modestbranding: 1,
              rel: 0
            }
          };
        } else {
          console.log('No matching embed container found, falling back to hidden player');
          playerContainer = createHiddenPlayerContainer(trackTitle);
          playerConfig = getHiddenPlayerConfig(videoId);
        }
      } else {
        console.log('Using hidden YouTube player for audio mode');
        playerContainer = createHiddenPlayerContainer(trackTitle);
        playerConfig = getHiddenPlayerConfig(videoId);
      }

      // Destroy existing player properly
      if (youtubeInterludeSystem.currentYouTubePlayer) {
        try {
          console.log('Destroying previous YouTube player');
          youtubeInterludeSystem.currentYouTubePlayer.stopVideo();
          youtubeInterludeSystem.currentYouTubePlayer.destroy();
          youtubeInterludeSystem.currentYouTubePlayer = null;
        } catch (error) {
          console.warn('Error destroying previous player:', error);
          youtubeInterludeSystem.currentYouTubePlayer = null;
        }
        
        // Wait a moment for cleanup
        setTimeout(() => {}, 100);
      }

      // Create new YouTube player
      youtubeInterludeSystem.currentYouTubePlayer = new YT.Player(playerContainer, {
        ...playerConfig,
        events: {
          onReady: function(event) {
            console.log('YouTube player ready for:', trackTitle, '- starting playback');
            try {
              event.target.playVideo();
              console.log('playVideo() called successfully for:', trackTitle);
            } catch (error) {
              console.error('Error calling playVideo() for:', trackTitle, error);
              reject(error);
            }
          },
          onStateChange: function(event) {
            console.log('YouTube player state changed:', event.data, 'for track:', trackTitle);
            
            if (event.data === YT.PlayerState.ENDED) {
              console.log('YouTube track ended:', trackTitle);
              
              // If using visible player, restore placeholder
              if (isVideoMode && playerContainer.classList && playerContainer.classList.contains('youtube-embed-container')) {
                playerContainer.innerHTML = `
                  <div class="youtube-placeholder">
                    <div class="youtube-placeholder-content">
                      <span class="youtube-icon">‚ñ∂</span>
                      <p>YouTube video will play here during interludes in video mode</p>
                    </div>
                  </div>
                `;
              }
              
              resolve();
            } else if (event.data === YT.PlayerState.PLAYING) {
              console.log('YouTube track playing:', trackTitle);
            } else if (event.data === YT.PlayerState.PAUSED && !youtubeInterludeSystem.userPaused) {
              console.log('YouTube track paused unexpectedly:', trackTitle);
            }
          },
          onError: function(event) {
            console.error('YouTube player error:', event.data);
            
            // If using visible player, restore placeholder
            if (isVideoMode && playerContainer.classList && playerContainer.classList.contains('youtube-embed-container')) {
              playerContainer.innerHTML = `
                <div class="youtube-placeholder">
                  <div class="youtube-placeholder-content">
                    <span class="youtube-icon">‚ñ∂</span>
                    <p>YouTube video will play here during interludes in video mode</p>
                  </div>
                </div>
              `;
            }
            
            reject(new Error(`YouTube player error: ${event.data}`));
          }
        }
      });
    });
  }

  // Helper function to create hidden player container
  function createHiddenPlayerContainer(trackTitle) {
    const existingContainer = document.getElementById('youtube-interlude-player');
    if (existingContainer) {
      existingContainer.remove();
    }
    
    const playerContainer = document.createElement('div');
    playerContainer.id = 'youtube-interlude-player';
    playerContainer.style.cssText = 'position: fixed; top: -1000px; left: -1000px; width: 1px; height: 1px;';
    document.body.appendChild(playerContainer);
    console.log('Created fresh hidden player container for:', trackTitle);
    return playerContainer;
  }

  // Helper function to get hidden player config
  function getHiddenPlayerConfig(videoId) {
    return {
      height: '1',
      width: '1',
      videoId: videoId,
      playerVars: {
        autoplay: 1,
        controls: 0,
        disablekb: 1,
        fs: 0,
        modestbranding: 1,
        rel: 0,
        showinfo: 0
      }
    };
  }

  // Stop YouTube interlude
  function stopYouTubeInterlude() {
    if (youtubeInterludeSystem.currentYouTubePlayer) {
      try {
        youtubeInterludeSystem.currentYouTubePlayer.stopVideo();
        youtubeInterludeSystem.currentYouTubePlayer.destroy();
        youtubeInterludeSystem.currentYouTubePlayer = null;
      } catch (error) {
        console.warn('Error stopping YouTube player:', error);
      }
    }
  }

  // Update UI to show YouTube interlude status
  function updateInterludeUI() {
    const interludeSections = document.querySelectorAll('.interlude-section');
    console.log('Found interlude sections for YouTube:', interludeSections.length);
    
    interludeSections.forEach(section => {
      let statusElement = section.querySelector('.youtube-status');
      if (!statusElement) {
        statusElement = document.createElement('div');
        statusElement.className = 'youtube-status';
        statusElement.style.cssText = `
          margin-bottom: 0.5rem;
          padding: 0.5rem;
          border-radius: 6px;
          font-size: 0.9rem;
          font-weight: 500;
          background: rgba(255, 0, 0, 0.1);
          color: #ff0000;
          border: 1px solid #ff0000;
        `;
        section.insertBefore(statusElement, section.firstChild);
      }

      statusElement.innerHTML = 'üì∫ YouTube interludes will auto-play between chapters';
    });
  }

  // Make functions globally available
  window.playYouTubeInterlude = playYouTubeInterlude;
  window.stopYouTubeInterlude = stopYouTubeInterlude;
  window.youtubeInterludeSystem = youtubeInterludeSystem;

  // Initialize YouTube system
  document.addEventListener('DOMContentLoaded', () => {
    console.log('YouTube interlude system initializing...');
    loadYouTubeAPI();
    updateInterludeUI();
  });
</script>

<!-- Multi-Format Transcript Sync System -->
<script>
  // Multi-Format Transcript Parser and Sync System
  class MultiFormatTranscriptSync {
    constructor() {
      this.transcriptData = [];
      this.currentSegmentIndex = -1;
      this.isTranscriptVisible = false;
      this.mediaPlayer = null;
      this.transcriptContainer = null;
      this.subtitleOverlay = null;
      this.transcriptStatus = null;
      this.formatDetected = null;
      this.isVideoMode = false;
      this.rawTranscriptData = null;
      
      this.init();
    }

    init() {
      console.log('Transcript: Initializing Multi-Format Transcript Sync System...');
      
      // Get DOM elements
      const transcriptToggle = document.getElementById('transcript-toggle');
      this.transcriptContainer = document.getElementById('transcript-container');
      this.subtitleOverlay = document.getElementById('subtitle-overlay');
      this.transcriptStatus = document.querySelector('.transcript-status');
      this.formatDetected = document.getElementById('format-detected');
      
      console.log('Transcript: DOM elements found:', {
        transcriptToggle: !!transcriptToggle,
        transcriptContainer: !!this.transcriptContainer,
        subtitleOverlay: !!this.subtitleOverlay,
        transcriptStatus: !!this.transcriptStatus,
        formatDetected: !!this.formatDetected
      });
      
      // Load and parse transcript data FIRST
      console.log('Transcript: Starting data loading...');
      this.loadRawTranscriptData();
      
      // Set up event listeners
      if (transcriptToggle) {
        transcriptToggle.addEventListener('click', () => this.toggleTranscript());
        console.log('Transcript: Toggle event listener added');
      }
      
      console.log('Transcript: Data loading complete. Parsed', this.transcriptData.length, 'segments');
      
      // Also check if transcript data is empty and show helpful message
      if (this.transcriptData.length === 0) {
        console.log('Transcript: No segments found. Check transcript format and data.');
        this.updateFormatDetected('No segments found', false);
      } else {
        console.log('Transcript: Successfully parsed segments, rendering transcript immediately...');
        // Render transcript immediately for users to read
        this.renderTranscriptHTML();
        // Show transcript by default when data is available
        this.showTranscriptByDefault();
        // Set up media sync for when playback starts (non-blocking)
        this.setupMediaPlayerSync();
      }
    }

    loadRawTranscriptData() {
      const rawDataElement = document.getElementById('transcript-raw-data');
      if (!rawDataElement) {
        console.log('Transcript: No transcript data element found on page');
        return;
      }

      try {
        this.rawTranscriptData = JSON.parse(rawDataElement.textContent);
        console.log('Transcript: Raw data loaded:', this.rawTranscriptData);
        
        if (this.rawTranscriptData.transcriptData && this.rawTranscriptData.transcriptData.trim()) {
          console.log('Transcript: Found transcript data, parsing...');
          this.parseTranscriptData(this.rawTranscriptData.transcriptData, this.rawTranscriptData.formatHint);
        } else {
          console.log('Transcript: No transcript content found in data');
          this.updateFormatDetected('No content', false);
        }
      } catch (error) {
        console.error('Transcript: Error loading data:', error);
        this.updateFormatDetected('Error loading data', false);
      }
    }

    parseTranscriptData(data, formatHint = 'auto') {
      console.log('Parsing transcript data with format hint:', formatHint);
      
      // Auto-detect format if not specified
      const detectedFormat = formatHint === 'auto' ? this.detectFormat(data) : formatHint;
      console.log('Detected format:', detectedFormat);
      
      this.updateFormatDetected(detectedFormat.toUpperCase(), true);
      
      try {
        switch (detectedFormat) {
          case 'webvtt':
            this.transcriptData = this.parseWEBVTT(data);
            break;
          case 'srt':
            this.transcriptData = this.parseSRT(data);
            break;
          case 'json':
            this.transcriptData = this.parseJSON(data);
            break;
          case 'simple':
            this.transcriptData = this.parseSimpleTimestamps(data);
            break;
          case 'csv':
            this.transcriptData = this.parseCSV(data);
            break;
          default:
            throw new Error(`Unsupported format: ${detectedFormat}`);
        }
        
        console.log('Parsed transcript data:', this.transcriptData);
        this.renderTranscriptHTML();
        
      } catch (error) {
        console.error('Error parsing transcript:', error);
        this.updateFormatDetected('Parse Error', false);
      }
    }

    detectFormat(data) {
      if (data.trim().startsWith('WEBVTT')) return 'webvtt';
      if (data.match(/^\d+\s*\n\d{2}:\d{2}:\d{2},\d{3} --> \d{2}:\d{2}:\d{2},\d{3}/m)) return 'srt';
      if (data.trim().startsWith('[') && data.trim().endsWith(']')) return 'json';
      if (data.includes(',') && (data.includes('"') || data.split('\n')[0].split(',').length > 2)) return 'csv';
      if (data.match(/\[\d{2}:\d{2}:\d{2}[\.\,]\d{3}\]/) || data.match(/\d{2}:\d{2}:\d{2}[\.\,]\d{3}:/)) return 'simple';
      return 'simple'; // fallback
    }

    parseWEBVTT(data) {
      console.log('Transcript: Parsing WEBVTT data...');
      console.log('Transcript: Data length:', data.length, 'characters');
      console.log('Transcript: First 200 characters:', data.substring(0, 200));
      
      const segments = [];
      const lines = data.split('\n');
      let currentSegment = null;
      let lineNumber = 0;
      
      console.log('Transcript: Total lines to process:', lines.length);
      
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        lineNumber++;
        
        // Skip WEBVTT header and empty lines
        if (line === 'WEBVTT' || line === '') continue;
        
        // Check for timestamp line - more flexible pattern for WEBVTT
        const timestampMatch = line.match(/^(\d{2}:\d{2}:\d{2}\.?\d{1,3}) --> (\d{2}:\d{2}:\d{2}\.?\d{1,3})/);
        if (timestampMatch) {
          // Save previous segment if exists
          if (currentSegment && currentSegment.text.length > 0) {
            segments.push({
              timestamp: currentSegment.startTime,
              endTimestamp: currentSegment.endTime,
              text: currentSegment.text.join(' '),
              speaker: currentSegment.speaker,
              type: 'speech',
              timeInSeconds: this.convertTimestampToSeconds(currentSegment.startTime),
              endTimeInSeconds: this.convertTimestampToSeconds(currentSegment.endTime)
            });
          }
          
          // Start new segment
          currentSegment = {
            startTime: timestampMatch[1],
            endTime: timestampMatch[2],
            text: [],
            speaker: this.rawTranscriptData?.defaultSpeaker || 'Host'
          };
          console.log(`Transcript: Found timestamp at line ${lineNumber}: ${timestampMatch[1]} --> ${timestampMatch[2]}`);
        } else if (currentSegment && line) {
          // Add text line to current segment
          currentSegment.text.push(line);
        }
      }
      
      // Don't forget the last segment
      if (currentSegment && currentSegment.text.length > 0) {
        segments.push({
          timestamp: currentSegment.startTime,
          endTimestamp: currentSegment.endTime,
          text: currentSegment.text.join(' '),
          speaker: currentSegment.speaker,
          type: 'speech',
          timeInSeconds: this.convertTimestampToSeconds(currentSegment.startTime),
          endTimeInSeconds: this.convertTimestampToSeconds(currentSegment.endTime)
        });
      }
      
      console.log(`Transcript: WEBVTT parsing complete. Found ${segments.length} segments.`);
      return segments;
    }

    parseSRT(data) {
      const segments = [];
      const blocks = data.trim().split(/\n\s*\n/);
      
      blocks.forEach(block => {
        const lines = block.trim().split('\n');
        if (lines.length >= 3) {
          const timestampLine = lines[1];
          const timestampMatch = timestampLine.match(/^(\d{2}:\d{2}:\d{2},\d{3}) --> (\d{2}:\d{2}:\d{2},\d{3})/);
          
          if (timestampMatch) {
            const startTime = timestampMatch[1].replace(',', '.');
            const endTime = timestampMatch[2].replace(',', '.');
            const text = lines.slice(2).join(' ');
            
            segments.push({
              timestamp: startTime,
              endTimestamp: endTime,
              text: text,
              speaker: this.rawTranscriptData?.defaultSpeaker || 'Host',
              type: 'speech',
              timeInSeconds: this.convertTimestampToSeconds(startTime),
              endTimeInSeconds: this.convertTimestampToSeconds(endTime)
            });
          }
        }
      });
      
      return segments;
    }

    parseJSON(data) {
      const segments = [];
      const jsonData = JSON.parse(data);
      
      jsonData.forEach(item => {
        segments.push({
          timestamp: item.start || item.timestamp || item.time,
          endTimestamp: item.end || item.endTime,
          text: item.text || item.content,
          speaker: item.speaker || this.rawTranscriptData?.defaultSpeaker || 'Host',
          type: item.type || 'speech',
          timeInSeconds: this.convertTimestampToSeconds(item.start || item.timestamp || item.time),
          endTimeInSeconds: item.end ? this.convertTimestampToSeconds(item.end) : undefined
        });
      });
      
      return segments;
    }

    parseSimpleTimestamps(data) {
      const segments = [];
      const lines = data.split('\n');
      
      lines.forEach(line => {
        const line_trimmed = line.trim();
        if (!line_trimmed) return;
        
        // Match [00:01:23.456] format or 00:01:23.456: format
        const match = line_trimmed.match(/^(?:\[)?(\d{1,2}:\d{2}:\d{2}(?:[\.\,]\d{3})?)\]?\s*:?\s*(.+)$/);
        if (match) {
          const timestamp = match[1];
          const text = match[2];
          
          segments.push({
            timestamp: timestamp,
            text: text,
            speaker: this.rawTranscriptData?.defaultSpeaker || 'Host',
            type: 'speech',
            timeInSeconds: this.convertTimestampToSeconds(timestamp)
          });
        }
      });
      
      return segments;
    }

    parseCSV(data) {
      const segments = [];
      const lines = data.split('\n');
      
      // Skip header row if it exists
      const startRow = lines[0].includes('timestamp') || lines[0].includes('time') ? 1 : 0;
      
      for (let i = startRow; i < lines.length; i++) {
        const line = lines[i].trim();
        if (!line) continue;
        
        const columns = line.split(',').map(col => col.replace(/^"/, '').replace(/"$/, ''));
        if (columns.length >= 2) {
          segments.push({
            timestamp: columns[0],
            text: columns[1],
            speaker: columns[2] || this.rawTranscriptData?.defaultSpeaker || 'Host',
            type: columns[3] || 'speech',
            timeInSeconds: this.convertTimestampToSeconds(columns[0])
          });
        }
      }
      
      return segments;
    }

    convertTimestampToSeconds(timestamp) {
      if (!timestamp) return 0;
      
      // Handle different timestamp formats
      const cleanTimestamp = timestamp.replace(',', '.');
      const parts = cleanTimestamp.split(':');
      let totalSeconds = 0;
      
      if (parts.length === 2) {
        // MM:SS.mmm format
        const [minutes, secondsMs] = parts;
        const [seconds, milliseconds = 0] = secondsMs.split('.');
        totalSeconds = parseInt(minutes) * 60 + parseInt(seconds) + (parseInt(milliseconds) / 1000);
      } else if (parts.length === 3) {
        // HH:MM:SS.mmm format
        const [hours, minutes, secondsMs] = parts;
        const [seconds, milliseconds = 0] = secondsMs.split('.');
        totalSeconds = parseInt(hours) * 3600 + parseInt(minutes) * 60 + parseInt(seconds) + (parseInt(milliseconds) / 1000);
      }
      
      return totalSeconds;
    }

    renderTranscriptHTML() {
      const contentContainer = document.getElementById('transcript-content');
      if (!contentContainer) return;
      
      contentContainer.innerHTML = '';
      
      this.transcriptData.forEach((segment, index) => {
        const segmentDiv = document.createElement('div');
        segmentDiv.className = 'transcript-segment';
        segmentDiv.dataset.timestamp = segment.timestamp;
        segmentDiv.dataset.segmentIndex = index;
        segmentDiv.dataset.speaker = segment.speaker || '';
        segmentDiv.dataset.type = segment.type || 'speech';
        
        segmentDiv.innerHTML = `
          <span class="timestamp">${segment.timestamp}</span>
          ${segment.speaker ? `<span class="speaker">${segment.speaker}:</span>` : ''}
          <span class="text">${segment.text}</span>
        `;
        
        // Store element reference for sync
        segment.element = segmentDiv;
        
        contentContainer.appendChild(segmentDiv);
      });
      
      console.log('Transcript HTML rendered with', this.transcriptData.length, 'segments');
    }

    updateFormatDetected(format, success) {
      if (this.formatDetected) {
        this.formatDetected.textContent = success ? format : `Error: ${format}`;
        this.formatDetected.classList.toggle('detected', success);
      }
    }

    setupMediaPlayerSync() {
      let attempts = 0;
      const maxAttempts = 20; // Max 20 attempts over ~30 seconds
      
      const trySetupPlayer = () => {
        attempts++;
        this.mediaPlayer = window.currentMediaPlayer;
        
        console.log(`Transcript: Sync attempt ${attempts}/${maxAttempts}, media player:`, !!this.mediaPlayer);
        
        if (this.mediaPlayer) {
          this.connectToMediaPlayer();
          return;
        }
        
        if (attempts >= maxAttempts) {
          console.log('Transcript: Media player not found after', maxAttempts, 'attempts. Transcript will work in manual mode.');
          this.updateStatus('Transcript ready - sync will activate when media plays');
          return;
        }
        
        // Try more frequently initially, then less frequently
        const delay = attempts < 5 ? 500 : (attempts < 10 ? 1000 : 2000);
        console.log(`Transcript: Waiting for media player (attempt ${attempts}/${maxAttempts}), next try in ${delay}ms`);
        setTimeout(trySetupPlayer, delay);
      };
      
      // Start trying immediately
      trySetupPlayer();
    }

    connectToMediaPlayer() {
      if (!this.mediaPlayer) return;
      
      console.log('Transcript: Media player found, setting up sync');
      console.log('Transcript: Media player type:', this.mediaPlayer.tagName);
      console.log('Transcript: Media player source:', this.mediaPlayer.src || this.mediaPlayer.currentSrc);
      
      // Remove old event listeners if they exist
      if (this.mediaPlayer.transcriptTimeUpdateListener) {
        this.mediaPlayer.removeEventListener('timeupdate', this.mediaPlayer.transcriptTimeUpdateListener);
      }
      if (this.mediaPlayer.transcriptPlayListener) {
        this.mediaPlayer.removeEventListener('play', this.mediaPlayer.transcriptPlayListener);
      }
      if (this.mediaPlayer.transcriptPauseListener) {
        this.mediaPlayer.removeEventListener('pause', this.mediaPlayer.transcriptPauseListener);
      }
      
      // Create new event listeners
      this.mediaPlayer.transcriptTimeUpdateListener = () => {
        console.log('Transcript: TimeUpdate event - currentTime:', this.mediaPlayer.currentTime);
        this.syncTranscript(this.mediaPlayer.currentTime);
      };
      
      this.mediaPlayer.transcriptPlayListener = () => {
        console.log('Transcript: Media player started playing');
      };
      
      this.mediaPlayer.transcriptPauseListener = () => {
        console.log('Transcript: Media player paused');
      };
      
      // Add new event listeners
      this.mediaPlayer.addEventListener('timeupdate', this.mediaPlayer.transcriptTimeUpdateListener);
      this.mediaPlayer.addEventListener('play', this.mediaPlayer.transcriptPlayListener);
      this.mediaPlayer.addEventListener('pause', this.mediaPlayer.transcriptPauseListener);
      
      this.updateStatus('Ready - transcript will sync during playback');
    }

    reconnectMediaPlayer() {
      console.log('Transcript: Reconnecting to new media player...');
      console.log('Transcript: Current connected player:', this.mediaPlayer?.tagName, this.mediaPlayer?.src || this.mediaPlayer?.currentSrc);
      console.log('Transcript: Window.currentMediaPlayer:', window.currentMediaPlayer?.tagName, window.currentMediaPlayer?.src || window.currentMediaPlayer?.currentSrc);
      
      const newMediaPlayer = window.currentMediaPlayer;
      
      if (newMediaPlayer !== this.mediaPlayer) {
        console.log('Transcript: New media player detected, switching connection');
        console.log('Transcript: Switching from', this.mediaPlayer?.tagName, 'to', newMediaPlayer?.tagName);
        this.mediaPlayer = newMediaPlayer;
        this.connectToMediaPlayer();
      } else {
        console.log('Transcript: Same media player, no reconnection needed');
      }
    }

    toggleTranscript() {
      this.isTranscriptVisible = !this.isTranscriptVisible;
      const toggleBtn = document.getElementById('transcript-toggle');
      const toggleText = toggleBtn.querySelector('.toggle-text');
      
      if (this.isTranscriptVisible) {
        this.transcriptContainer.style.display = 'block';
        toggleText.textContent = 'Hide Transcript';
        this.updateStatus('Transcript visible - sync active');
        
        this.checkDisplayMode();
      } else {
        this.transcriptContainer.style.display = 'none';
        toggleText.textContent = 'Show Transcript';
        this.updateStatus('Transcript hidden');
      }
    }

    showTranscriptByDefault() {
      // Automatically show transcript when data is available
      this.isTranscriptVisible = true;
      const toggleBtn = document.getElementById('transcript-toggle');
      const toggleText = toggleBtn ? toggleBtn.querySelector('.toggle-text') : null;
      
      if (this.transcriptContainer) {
        this.transcriptContainer.style.display = 'block';
        console.log('Transcript: Showing transcript by default since data is available');
      }
      
      if (toggleText) {
        toggleText.textContent = 'Hide Transcript';
      }
      
      this.updateStatus('Transcript loaded and ready');
      this.checkDisplayMode();
    }

    checkDisplayMode() {
      const episodeContainer = document.querySelector('.episode-container');
      this.isVideoMode = episodeContainer && !episodeContainer.classList.contains('audio-only-view');
      
      console.log('Transcript: Current display mode:', this.isVideoMode ? 'video' : 'audio');
      console.log('Transcript: isTranscriptVisible:', this.isTranscriptVisible);
      console.log('Transcript: subtitleOverlay element:', !!this.subtitleOverlay);
      console.log('Transcript: transcriptContainer element:', !!this.transcriptContainer);
      
      if (this.isVideoMode && this.isTranscriptVisible) {
        // In video mode, show subtitles instead of scrolling transcript
        console.log('Transcript: Switching to video mode - showing subtitles');
        if (this.subtitleOverlay) {
          this.subtitleOverlay.style.display = 'block';
        }
        if (this.transcriptContainer) {
          this.transcriptContainer.style.display = 'none';
        }
      } else if (this.isTranscriptVisible) {
        // In audio mode, show scrolling transcript
        console.log('Transcript: Switching to audio mode - showing transcript container');
        if (this.subtitleOverlay) {
          this.subtitleOverlay.style.display = 'none';
        }
        if (this.transcriptContainer) {
          this.transcriptContainer.style.display = 'block';
        }
      }
    }

    syncTranscript(currentTime) {
      if (!this.isTranscriptVisible || this.transcriptData.length === 0) {
        return;
      }

      // Find the current segment based on timestamp
      let activeSegmentIndex = -1;
      
      for (let i = 0; i < this.transcriptData.length; i++) {
        const segment = this.transcriptData[i];
        const nextSegment = this.transcriptData[i + 1];
        
        if (currentTime >= segment.timeInSeconds) {
          if (!nextSegment || currentTime < nextSegment.timeInSeconds) {
            activeSegmentIndex = i;
            break;
          }
        }
      }

      // Update active segment if changed
      if (activeSegmentIndex !== this.currentSegmentIndex) {
        this.updateActiveSegment(activeSegmentIndex);
      }
    }

    updateActiveSegment(newIndex) {
      // Remove active class from previous segment
      if (this.currentSegmentIndex >= 0 && this.transcriptData[this.currentSegmentIndex]) {
        this.transcriptData[this.currentSegmentIndex].element.classList.remove('active');
      }

      this.currentSegmentIndex = newIndex;

      if (newIndex >= 0 && this.transcriptData[newIndex]) {
        const activeSegment = this.transcriptData[newIndex];
        
        console.log('Transcript: Active segment changed to:', activeSegment.text.substring(0, 50) + '...');
        
        // Add active class to current segment
        activeSegment.element.classList.add('active');
        
        // Update display based on current mode
        this.checkDisplayMode();
        
        if (this.isVideoMode) {
          // Show as subtitle overlay
          console.log('Transcript: In video mode, displaying subtitle');
          this.displaySubtitle(activeSegment);
        } else {
          // Scroll to active segment in transcript container
          console.log('Transcript: In audio mode, scrolling to segment');
          this.scrollToActiveSegment(activeSegment);
        }
        
        this.updateStatus(`Speaking: ${activeSegment.speaker || 'Unknown'} at ${activeSegment.timestamp}`);
      }
    }

    displaySubtitle(segment) {
      console.log('Transcript: displaySubtitle called with segment:', segment.text.substring(0, 50) + '...');
      
      if (!this.subtitleOverlay) {
        console.log('Transcript: No subtitle overlay element found');
        return;
      }
      
      console.log('Transcript: Subtitle overlay element found:', this.subtitleOverlay);
      console.log('Transcript: Subtitle overlay current display:', this.subtitleOverlay.style.display);
      
      const subtitleText = this.subtitleOverlay.querySelector('.subtitle-text');
      if (subtitleText) {
        console.log('Transcript: Setting subtitle text:', segment.text);
        subtitleText.textContent = segment.text;
        this.subtitleOverlay.style.display = 'block';
        
        console.log('Transcript: Subtitle overlay after setting display block:', this.subtitleOverlay.style.display);
        console.log('Transcript: Subtitle overlay computed style:', getComputedStyle(this.subtitleOverlay).display);
        console.log('Transcript: Subtitle overlay position:', getComputedStyle(this.subtitleOverlay).position);
        
        // Ensure subtitle overlay is positioned correctly
        // First try to find an active video container
        let videoContainer = document.querySelector('.media-container.active');
        if (!videoContainer) {
          // Fallback to any media container that's visible
          videoContainer = document.querySelector('.media-container:not([style*="display: none"])');
        }
        if (!videoContainer) {
          // Final fallback - just use the episode container
          videoContainer = document.querySelector('.episode-container');
        }
        
        console.log('Transcript: Found video container:', videoContainer?.tagName, videoContainer?.className);
        
        if (videoContainer && !videoContainer.contains(this.subtitleOverlay)) {
          console.log('Transcript: Moving subtitle overlay to video container');
          videoContainer.style.position = 'relative'; // Ensure container is positioned
          videoContainer.appendChild(this.subtitleOverlay);
          console.log('Transcript: Subtitle overlay moved to:', videoContainer.tagName);
        } else if (videoContainer) {
          console.log('Transcript: Subtitle overlay already in video container');
        }
        
        // Force styles to ensure visibility
        this.subtitleOverlay.style.zIndex = '9999';
        this.subtitleOverlay.style.pointerEvents = 'none';
        
        
        console.log('Transcript: Final subtitle overlay styles:', {
          display: this.subtitleOverlay.style.display,
          position: getComputedStyle(this.subtitleOverlay).position,
          zIndex: this.subtitleOverlay.style.zIndex,
          bottom: getComputedStyle(this.subtitleOverlay).bottom
        });
      } else {
        console.log('Transcript: No .subtitle-text element found inside overlay');
      }
    }

    scrollToActiveSegment(segment) {
      if (!this.transcriptContainer) return;
      
      // Scroll the active segment into view
      segment.element.scrollIntoView({
        behavior: 'smooth',
        block: 'center',
        inline: 'nearest'
      });
    }

    updateStatus(message) {
      if (this.transcriptStatus) {
        this.transcriptStatus.textContent = message;
        this.transcriptStatus.classList.add('active');
        
        setTimeout(() => {
          this.transcriptStatus.classList.remove('active');
        }, 2000);
      }
    }
  }

  // Initialize transcript system when DOM is ready
  document.addEventListener('DOMContentLoaded', () => {
    // Only initialize if transcript data exists
    if (document.getElementById('transcript-raw-data')) {
      console.log('Transcript data found, initializing multi-format sync system...');
      window.transcriptSync = new MultiFormatTranscriptSync();
    } else {
      console.log('No transcript data found for this episode');
    }
  });

  // Hook into existing media toggle system to update transcript display mode
  const originalMediaToggle = document.querySelectorAll('[data-type]');
  originalMediaToggle.forEach(btn => {
    btn.addEventListener('click', () => {
      setTimeout(() => {
        if (window.transcriptSync) {
          window.transcriptSync.checkDisplayMode();
        }
      }, 100);
    });
  });
</script>